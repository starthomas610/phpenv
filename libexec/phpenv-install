#!/bin/bash
  # alias autoconf=autoconf213
  # shopt -s expand_aliases
  # autoconf --version


# The most important line in every shell script. Basically this says:
# This script should fail once a command invocation itself fails.
set -e

# Set the `PHPENV_DEBUG` environment variable to
# `yes` to trigger the `set -x` call, which in turn
# outputs every issued shell command to `STDOUT`.
[[ -n "$PHPENV_DEBUG" ]] && set -x

# Preserve STDERR on FD3, so we can easily log build errors on
# FD2 to a file and use FD3 for visible error messages.
exec 3<&2
STATUS=0
CONTINUE=0
# Process flow and continuation
# ------------------------------
function workflow() {
  case "$1" in

    0)  # update the repo
        fetch_releases
      ;;
    1)  # checkout re/ease to branch build
        build_branch
      ;;
    2)  # run configure
        patch_bingo
      ;;
    3)  # run configure
        configure_release
      ;;
    4)  # compile
        build_release
      ;;
    5)  # create configuration
        make_php_ini
      ;;
    6)  # install pyrus
        install_pyrus
      ;;
    7)  # install custom extensions
        build_extensions
      ;;
    *)  # This should not happen
        log "Error" "Unexpected workflow status $1, aborting"
        exit $1
      ;;
  esac
}

function continue_after() {
  if [ ${CONTINUE} -gt $1 ]; then
    log "$2" "Omitted continue from $CONTINUE"
    echo $
    [[ ${STATUS} -le 7 ]] && workflow ${STATUS}
    return 0
  fi
  return 1
}

# Utility Functions
# -----------------

# processes the usage message for the script and displays it on STDERR.
function display_usage() {
  grep '^#/' <"$0" | cut -c4- >&3
}

# clones the php-src repo if it doesn't exist
function init() {
  if [[ ! -d "$SRC_DIR" ]]; then
    log "Cloning" "source from php-src Github repo"
    ${GIT} clone "$SRC_URL" "$SRC_DIR" &> /dev/null
  fi
}

# logs the given log text with a [marker] to STDERR.
  [[ -n $1 ]] && local marker="[$1]"
function log() {
  local marker=""
  local text="$2"
  if [ 0 -lt ${#1} ]; then
    if [[ 7 -ge ${STATUS} && ${1:0:4} != 'make' ]]; then
      let "STATUS+=1"
      marker="[$1]"
      text="|$STATUS| $2"
    else
      marker="$1:"
    fi
  fi

  printf "%35s %-65s\n" "$marker" "$text"  >&3
}

# uses uname to check if running OSX
# this is used later on to enable specifc fixes for
# OSX oddnesses in library file placement
function is_osx() {
  return $(test $(uname) == "Darwin")
}

# gets latest code from github repo
function fetch_releases() {
  continue_after 0 "Fetching" && return

  if ${GIT} branch|grep -q '* master'; then
    log "Fetching" "latest code from Github repo"
    ${GIT} pull &> /dev/null
  else
    cleanup
    fetch_releases
  fi
}

# lists all releases found in the github repo
function list_releases() {
  cd "$SRC_DIR"
  fetch_releases
  local release_out=""
  for release in $(${GIT} tag | sed '/php-/!d'); do
    release_out="$release_out\n$release"
  done
  release_out="PHP releases as were available on:\n$(date)
  \n$(echo -e "$release_out" | sort -bt. -k1,1r -k2,2nr -k3.1,3.2nr)"
  [[ -n ${PAGER} ]] && echo -e "$release_out" | ${PAGER} || echo -e "$release_out" | less
  unset release_out
}

# Handles build errors, and displays the last 10 line of the build log.
function build_error() {
  {
    echo
    echo "BUILD ERROR: STATUS is $STATUS"
    echo "The script aborted unexpectedly when a command returned a non zero exit code."
    if awk 'END{exit NR == 0};' $LOG_PATH.err; then
      echo "Last 10 linens from the error log file may shed some light"
      echo "-------------------------------------------------------------------------------------"
      echo "$(tail -n10 "$LOG_PATH.err")"
      echo
      echo "-------------------------------------------------------------------------------------"
    else
      echo "Unfortunately the error log file appears to be empty, perhaps the STDOUT log may be of help to you."
    fi
    echo
    echo "The full STDERR Log is available here $LOG_PATH.err"
    echo "The full STDOUT Log is available here $LOG_PATH"
    [[ -z $PAGER ]] && PAGER=less
    test `which pbcopy` && (echo $PAGER $LOG_PATH | `which pbcopy`) && echo "The command to view the logfile with \$PAGER has been copied to your clipboard."

    echo
    reset_streams
  } >&3
}

# cleans up our build environment
function cleanup() {
  cd "$SRC_DIR"
  ${GIT} checkout -f master && ${GIT} branch -D build &> /dev/null
}

# Reset the default streams and close file descriptors
function reset_streams() {
  exec 2>&3 4>&- 3>&- 1>&5 5>&-
}

# sets and unsets arguments for `configure`. Pass it the `-D` option to unset
# the argument given in `$2`. Otherwise the first argument is the name of the
# option and the second argument contains the optional value.
function configure_option() {
  if [[ "$1" = "-D" ]]; then
    # This variable will contain the filtered arguments.
    local filtered=

    for option in ${CONFIGURE_OPTIONS}; do
      # If the argument starts with the given string in `$1`
      # then skip it from concatenation. Otherwise add it to
      # the filtered options.
      case "$option" in
        "$2"*) ;;
        *) filtered="$filtered $option";;
      esac
    done
    
    # Trim the leading whitespace added in the concatenation.
    filtered=$(echo "$filtered" | sed -e 's/[ ]*//')

    # Then replace the old argument list with the new one.
    CONFIGURE_OPTIONS="$filtered"
    return 0
  else
    if [[ "$1" = "-R" ]]; then
      configure_option -D "$2"
      configure_option "$2" "$3"
      return 0
    fi
  fi

  CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS $1"

  [[ -n "$2" ]] && CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS=$2"
}

# Package Manager Functions
# -------------------------

# configures a `pear` install in `$PREFIX/pear`
function enable_pear() {
  [[ ! -d "$PREFIX/pear" ]] && mkdir -p "$PREFIX/pear"
  configure_option "--with-pear" "$PREFIX/pear"
}

# installs Pyrus
function install_pyrus() {
  continue_after 6 "Pyrus" && return

  local pyrus_url="http://pear2.php.net/pyrus.phar"
  local pyrus_bin="$PREFIX/bin/pyrus"
  local pyrus_home="$PREFIX/share/pyrus"

  log "Pyrus" "downloading and installing from $pyrus_url"

  # if pyrus doesn't exist, download it
  [[ ! -f "$PREFIX/bin/pyrus.phar" ]] && wget -qP "$PREFIX/bin/" $pyrus_url
  
  # if $pyrus_home doesn't exist, create it
  [[ ! -d "$pyrus_home" ]] && mkdir -p "$pyrus_home"

  # Add the directory where PEAR Packages get installed, to PHP's include path
  local default_include_path=$("$PREFIX/bin/php" -r "echo get_include_path();")
  echo "include_path=$default_include_path:$PREFIX/share/pyrus/.pear/php" > "$PREFIX/etc/conf.d/pyrus.ini"

  # Create the Pyrus executable
  cat > "$PREFIX/bin/pyrus" <<SH
#!/usr/bin/env bash
export HOME="$pyrus_home"
"$PREFIX/bin/php" -dphar.readonly=0 "$PREFIX/bin/pyrus.phar" \$@
SH

  chmod 755 "$PREFIX/bin/pyrus"

  if [[ ! -f "$pyrus_home/.pear/pearconfig.xml" ]]; then

    [[ ! -d "$pyrus_home/.pear" ]] && mkdir "$pyrus_home/.pear"

    # Create the default pearconfig.xml by hand, otherwise the
    # User would be asked for the PEAR path on the first run.
    cat > "$pyrus_home/.pear/pearconfig.xml" <<EOF
<?xml version="1.0"?>
<pearconfig version="1.0">
<default_channel>pear2.php.net</default_channel>
<auto_discover>0</auto_discover>
<http_proxy></http_proxy>
<cache_dir>$pyrus_home/.pear/cache</cache_dir>
<temp_dir>$pyrus_home/.pear/tmp</temp_dir>
<verbose>1</verbose>
<preferred_state>beta</preferred_state>
<umask>0022</umask>
<cache_ttl>3600</cache_ttl>
<my_pear_path>$pyrus_home/.pear</my_pear_path>
<plugins_dir>$pyrus_home/.pear</plugins_dir>
</pearconfig>
EOF

  fi

  local ext_dir=$("$PREFIX/bin/php" -r "echo ini_get('extension_dir');")

  "$pyrus_bin" set bin_dir "$PREFIX/bin/" > /dev/null
  "$pyrus_bin" set php_prefix "$PREFIX/bin/" > /dev/null
  "$pyrus_bin" set ext_dir "$ext_dir" > /dev/null
}

# Install / Build Functions
# -------------------------

# kicks off the entire build / install process
# and sends output to the log file
function install_release() {
  {
    PREFIX="$PHPENV_ROOT/versions/$VERSION"
    build_release
  } 2>&4
}

# handles all the heavy lifting when building $RELEASE
  local cwd="$(pwd)"
  local valid=
  cd "$SRC_DIR"
  continue_after 7 "Extensions" && return


  # verify chosen release before continuing
  for release in $($GIT tag | sed '/php-/!d' | cut -f3 -d/); do
    [[ $RELEASE = $release ]] && valid=true
  done

  if [[ ! $valid ]]; then
    log "Error" "Release $RELEASE not found."
    exit $E_RELEASE_NOT_FOUND
  fi

  # update the repo
  fetch_releases
  continue_after 1 "Branching" && return

  log "Branching" "for a clean build environment"
  $GIT checkout -b build $RELEASE > /dev/null

  log "Configuring" "build options for selected release"
  configure_release
  
function build_release() {
  continue_after 4 "Compiling" && return

  log "Compiling" "$PREFIX"
    make
    make install
    make clean
function make_php_ini() {
  continue_after 5 "Config ini" && return

  if [[ -n "$DEFAULT_INI" ]]; then
    if [[ -f "$PREFIX/$DEFAULT_INI" ]]; then
      cp "$PREFIX/$DEFAULT_INI" "$PREFIX/etc/php.ini"
    else
      if [[ -f "$DEFAULT_INI" ]]; then
        cp "$DEFAULT_INI" "$PREFIX/etc/php.ini"
      fi
    fi
  fi

  # install Pyrus if PHP version > 5.2
  [[ $VERSION_MAJOR = 5 && $VERSION_MINOR > 2 ]] && install_pyrus

  # remove build branch
  $GIT checkout . && $GIT checkout master && $GIT branch -D build > /dev/null

  $PHPENV_ROOT/bin/phpenv rehash
  continue_after 2 "Patching" && return

  cd "$cwd"
}

# This is invoked by `build_release` and is used to
# build PHP with the arguments in `$CONFIGURE_OPTIONS`.
# It also determines whether or not to install PEAR or Pyrus
function configure_release() {
  continue_after 3 "Configuring" && return


  # Mac OSX stores some libraries (for example `libpng`)
  # in `/usr/X11/lib` instead of `/usr/lib`.
  #
  # This currently builds PHP without the `gettext` and `readline`
  # extensions, as I've currently not got them to work on my machine.
  if is_osx; then
    configure_option -D "--with-gettext"
    configure_option -D "--with-readline"
    configure_option    "--with-libedit"
    configure_option -R "--with-png-dir" "/usr/X11"
  fi

  # Add the config-file-path, config-file-scan-dir aswell as the
  # prefix to the build options, these cannot be changed by definitions.
  local argv="$CONFIGURE_OPTIONS \
--with-config-file-path="$PREFIX/etc" \
--with-config-file-scan-dir="$PREFIX/etc/conf.d" \
--prefix=$PREFIX"
  
  if [ ! -d "$PREFIX/etc/conf.d" ]; then
    mkdir -p "$PREFIX/etc/conf.d"
  fi

  # Set the lib dir to `lib64` on **x86_64** systems.
  if [ "$(uname -p)" = "x86_64" ]; then
    argv="$argv --with-libdir=lib64"
  fi

  # enable PEAR if PHP version < 5.3
  [[ $VERSION_MAJOR < 5 || $VERSION_MINOR < 3 ]] && enable_pear

  # perform build / configure
  ./buildconf --force > /dev/null

  phpenv-hooks install pre-configure

  ./configure $argv > /dev/null

  phpenv-hooks install post-configure

}

# Here the magic begins
# ---------------------
GIT=$(which git)
SRC_DIR="$PHPENV_ROOT/php-src"
SRC_URL="https://github.com/php/php-src.git"

# always ensure we have cloned the php-src repo
init

# Display the Usage message if no arguments are given.
if [[ -z $1 || "$1" = "--help" || "$1" = "-h" ]]; then
  display_usage
  exit 1
fi

# display list of available releases if --releases was passed in
if [[ "$1" = "--releases" ]]; then
  list_releases
  exit 0
fi


# If `-i` or `--ini` is given as first argument, then
# treat the second argument as `php.ini` file.
if [[ "$1" = "-i" || "$1" = "--ini" ]]; then
  # If an existing path is passed (and the path is a file)
  # then use this file, otherwise use `php.ini-<value>`
  # from the tarball.
  if [[ -f "$2" ]]; then
    DEFAULT_INI="$2"
  else
    DEFAULT_INI="php.ini-$2"
  fi
  shift
  shift
  echo "$DEFAULT_INI gets used as php.ini"
fi

# grab the release that the user wants to build
RELEASE=$1
BUILD=$2
if [[ "$2" = "-c" || "$2" = "--continue" ]]; then
  CONTINUE=${3}
  BUILD=""
fi
if [[ "$3" = "-c" || "$3" = "--continue" ]]; then
  CONTINUE=${4}
fi
# Generate the Path for the build log.
LOG_PATH="/tmp/phpenv-install-$RELEASE.$(date "+%Y%m%d%H%M%S").log"
# Redirect everything logged to STDOUT to the Log file.
exec 5>$1
exec >$LOG_PATH
# Redirect everything logged to STDERR to the .err Log file.
exec 4<>$LOG_PATH.err

# Source the build configuration
PHPENV_ROOT="$( dirname $( dirname "$0" ) )"
source "$PHPENV_ROOT/etc/config.source"

echo -e "Building $VERSION\n" >&2

# Handle script termination with the `cleanup_abort`.
trap cleanup_abort SIGINT SIGTERM

# Handle Script Errors with `build_error`.
trap build_error ERR EXIT

# start build / install process
install_release

# Unbind the error handler.
trap - ERR
trap - EXIT

# Display a success Notice
log "Success" "The installation of the $RELEASE release was successfully completed."
log "Info" "The log files produced by the procedure are available, in the tmp folder, for your review:"
log "" " - Any warnings or messeages sent to STDERR was logged to $LOG_PATH.err"
log "" " - All messeages sent to STDOUT was logged to $LOG_PATH"
[[ -z $PAGER ]] && PAGER=less
test `which pbcopy` && (echo $PAGER $LOG_PATH | `which pbcopy`) && echo "The command to view the logfile with \$PAGER has been copied to your clipboard."

trap - SIGINT
trap - SIGTERM

# Reset the default streams and close file descriptors
reset_streams
