#!/bin/bash
# The most important line in every shell script. Basically this says:
# This script should fail once a command invocation itself fails.
set -e

#/ Usage: phpenv install [--releases] [--ini|i <environment>] [<release>]
#/
#/ Arguments:
#/   release:    What release should be built
#/
#/ Options:
#/   --releases: Lists all available definitions
#/
#/   --ini|i:    Specifies which php.ini-<environment> from the
#/               source distribution is used as default php.ini
#/

# Set the `PHPENV_DEBUG` environment variable to
# `yes` to trigger the `set -x` call, which in turn
# outputs every issued shell command to `STDOUT`.
[[ -n "$PHPENV_DEBUG" ]] && set -x

# Preserve STDERR on FD3, so we can easily log build errors on
# FD2 to a file and use FD3 for visible error messages.
exec 3<&2

# Useful Variables
# ----------------

GIT=$(which git)
PHPENV_ROOT="$( dirname $( dirname "$0" ) )"
SRC_DIR="$PHPENV_ROOT/php-src"
SRC_URL="https://github.com/php/php-src.git"

# If `-i` or `--ini` is given as first argument, then
# treat the second argument as `php.ini` file.
if [[ "$1" = "-i" || "$1" = "--ini" ]]; then
  # If an existing path is passed (and the path is a file)
  # then use this file, otherwise use `php.ini-<value>`
  # from the tarball.
  if [[ -f "$2" ]]; then
    DEFAULT_INI="$2"
  else
    DEFAULT_INI="php.ini-$2"
  fi
  shift
  shift
fi

# grab the release that the user wants to build
RELEASE=$1

# Utility Functions
# -----------------

# processes the usage message for the script and displays it on STDERR.
function display_usage {
  grep '^#/' <"$0" | cut -c4- >&3
}

# clones the php-src repo if it doesn't exist
function init {
  if [[ ! -d "$SRC_DIR" ]]; then
    log "Cloning" "source from php-src Github repo"
    $GIT clone "$SRC_URL" "$SRC_DIR" &> /dev/null
  fi
}

# logs the given log text with a [marker] to STDERR.
function log {
  [[ -n $1 ]] && local marker="[$1]"
  local text="$2"
  printf "%35s : %-65s\n" "$marker" "$text"  >&3
}

# uses uname to check if running OSX
# this is used later on to enable specifc fixes for
# OSX oddnesses in library file placement
function is_osx {
  return $(test $(uname) == "Darwin")
}

# gets latest code from github repo
function fetch_releases {
  if git branch|grep -q '* master'; then
    log "Fetching" "latest code from Github repo"
    $GIT pull &> /dev/null
  else
    cleanup
    fetch_releases
  fi
}

# lists all releases found in the github repo
function list_releases {
  cd "$SRC_DIR"
  fetch_releases
  local release_out=""
  for release in $($GIT tag | sed '/php-/!d'); do
    release_out="$release_out\n$release"
  done
  release_out="PHP releases as were available on:\n$(date)
  \n$(echo -e "$release_out" | sort -bt. -k1,1r -k2,2nr -k3.1,3.2nr)"
  [[ -n $PAGER ]] && echo -e "$release_out" | $PAGER || echo -e "$release_out" | less
  unset release_out
}

# Handles build errors, and displays the last 10 line of the build log.
function build_error {
  {
    echo
    echo "BUILD ERROR: STATUS is $STATUS"
    echo "The script aborted unexpectedly when a command returned a non zero exit code."
    if awk 'END{exit NR == 0};' $LOG_PATH.err; then
      echo "Last 10 linens from the error log file may shed some light"
      echo "-------------------------------------------------------------------------------------"
      echo "$(tail -n10 "$LOG_PATH.err")"
      echo
      echo "-------------------------------------------------------------------------------------"
    else
      echo "Unfortunately the error log file appears to be empty, perhaps the STDOUT log may be of help to you."
    fi
    echo
    echo "The full STDERR Log is available here $LOG_PATH.err"
    echo "The full STDOUT Log is available here $LOG_PATH"
    [[ -z $PAGER ]] && PAGER=less
    test `which pbcopy` && (echo $PAGER $LOG_PATH | `which pbcopy`) && echo "The command to view the logfile with \$PAGER has been copied to your clipboard."

    echo
  } >&3
  
  # Removes the prefix when the build fails.
  cleanup_abort
}

# cleans up our build environment if we error out
function cleanup_abort {
  {
    rm -rf "$PREFIX"
    cd "$SRC_DIR"
    $GIT checkout . && $GIT checkout master && $GIT branch -D build &> /dev/null
  }
  exec 2>&3 4>&- 3>&- 1>&5 5>&-
}

# sets and unsets arguments for `configure`. Pass it the `-D` option to unset
# the argument given in `$2`. Otherwise the first argument is the name of the
# option and the second argument contains the optional value.
function configure_option {
  if [[ "$1" = "-D" ]]; then
    # This variable will contain the filtered arguments.
    local filtered=

    for option in $CONFIGURE_OPTIONS; do
      # If the argument starts with the given string in `$1`
      # then skip it from concatenation. Otherwise add it to
      # the filtered options.
      case "$option" in
        "$2"*) ;;
        *) filtered="$filtered $option";;
      esac
    done
    
    # Trim the leading whitespace added in the concatenation.
    filtered=$(echo "$filtered" | sed -e 's/[ ]*//')

    # Then replace the old argument list with the new one.
    CONFIGURE_OPTIONS="$filtered"
    return 0
  else
    if [[ "$1" = "-R" ]]; then
      configure_option -D "$2"
      configure_option "$2" "$3"
      return 0
    fi
  fi

  CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS $1"

  [[ -n "$2" ]] && CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS=$2"
}

# Package Manager Functions
# -------------------------

# configures a `pear` install in `$PREFIX/pear`
function enable_pear {
  [[ ! -d "$PREFIX/pear" ]] && mkdir -p "$PREFIX/pear"
  configure_option "--with-pear" "$PREFIX/pear"
}

# installs Pyrus
function install_pyrus {
  local pyrus_url="http://pear2.php.net/pyrus.phar"
  local pyrus_bin="$PREFIX/bin/pyrus"
  local pyrus_home="$PREFIX/share/pyrus"

  log "Pyrus" "downloading and installing from $pyrus_url"

  # if pyrus doesn't exist, download it
  [[ ! -f "$PREFIX/bin/pyrus.phar" ]] && wget -qP "$PREFIX/bin/" $pyrus_url
  
  # if $pyrus_home doesn't exist, create it
  [[ ! -d "$pyrus_home" ]] && mkdir -p "$pyrus_home"

  # Add the directory where PEAR Packages get installed, to PHP's include path
  local default_include_path=$("$PREFIX/bin/php" -r "echo get_include_path();")
  echo "include_path=$default_include_path:$PREFIX/share/pyrus/.pear/php" > "$PREFIX/etc/conf.d/pyrus.ini"

  # Create the Pyrus executable
  cat > "$PREFIX/bin/pyrus" <<SH
#!/usr/bin/env bash
export HOME="$pyrus_home"
"$PREFIX/bin/php" -dphar.readonly=0 "$PREFIX/bin/pyrus.phar" \$@
SH

  chmod 755 "$PREFIX/bin/pyrus"

  if [[ ! -f "$pyrus_home/.pear/pearconfig.xml" ]]; then

    [[ ! -d "$pyrus_home/.pear" ]] && mkdir "$pyrus_home/.pear"

    # Create the default pearconfig.xml by hand, otherwise the
    # User would be asked for the PEAR path on the first run.
    cat > "$pyrus_home/.pear/pearconfig.xml" <<EOF
<?xml version="1.0"?>
<pearconfig version="1.0">
<default_channel>pear2.php.net</default_channel>
<auto_discover>0</auto_discover>
<http_proxy></http_proxy>
<cache_dir>$pyrus_home/.pear/cache</cache_dir>
<temp_dir>$pyrus_home/.pear/tmp</temp_dir>
<verbose>1</verbose>
<preferred_state>beta</preferred_state>
<umask>0022</umask>
<cache_ttl>3600</cache_ttl>
<my_pear_path>$pyrus_home/.pear</my_pear_path>
<plugins_dir>$pyrus_home/.pear</plugins_dir>
</pearconfig>
EOF

  fi

  local ext_dir=$("$PREFIX/bin/php" -r "echo ini_get('extension_dir');")

  "$pyrus_bin" set bin_dir "$PREFIX/bin/" > /dev/null
  "$pyrus_bin" set php_prefix "$PREFIX/bin/" > /dev/null
  "$pyrus_bin" set ext_dir "$ext_dir" > /dev/null
}

# Install / Build Functions
# -------------------------

# kicks off the entire build / install process
# and sends output to the log file
function install_release {
  {
    PREFIX="$PHPENV_ROOT/versions/$VERSION"
    build_release
  } 2>&4
}

# handles all the heavy lifting when building $RELEASE
function build_release {
  local cwd="$(pwd)"
  local valid=
  cd "$SRC_DIR"

  # verify chosen release before continuing
  for release in $($GIT tag | sed '/php-/!d' | cut -f3 -d/); do
    [[ $RELEASE = $release ]] && valid=true
  done

  if [[ ! $valid ]]; then
    log "Error" "Release $RELEASE not found."
    exit $E_RELEASE_NOT_FOUND
  fi

  # update the repo
  fetch_releases

  log "Branching" "for a clean build environment"
  $GIT checkout -b build $RELEASE > /dev/null

  log "Configuring" "build options for selected release"
  configure_release
  
  log "Compiling" "$PREFIX"
    make
    make install
    make clean

  if [[ -n "$DEFAULT_INI" ]]; then
    if [[ -f "$PREFIX/$DEFAULT_INI" ]]; then
      cp "$PREFIX/$DEFAULT_INI" "$PREFIX/etc/php.ini"
    else
      if [[ -f "$DEFAULT_INI" ]]; then
        cp "$DEFAULT_INI" "$PREFIX/etc/php.ini"
      fi
    fi
  fi

  # install Pyrus if PHP version > 5.2
  [[ $VERSION_MAJOR = 5 && $VERSION_MINOR > 2 ]] && install_pyrus

  # remove build branch
  $GIT checkout . && $GIT checkout master && $GIT branch -D build > /dev/null

  $PHPENV_ROOT/bin/phpenv rehash

  cd "$cwd"
}

# This is invoked by `build_release` and is used to
# build PHP with the arguments in `$CONFIGURE_OPTIONS`.
# It also determines whether or not to install PEAR or Pyrus
function configure_release {

  # Mac OSX stores some libraries (for example `libpng`)
  # in `/usr/X11/lib` instead of `/usr/lib`.
  #
  # This currently builds PHP without the `gettext` and `readline`
  # extensions, as I've currently not got them to work on my machine.
  if is_osx; then
    configure_option -D "--with-gettext"
    configure_option -D "--with-readline"
    configure_option    "--with-libedit"
    configure_option -R "--with-png-dir" "/usr/X11"
  fi

  # Add the config-file-path, config-file-scan-dir aswell as the
  # prefix to the build options, these cannot be changed by definitions.
  local argv="$CONFIGURE_OPTIONS \
--with-config-file-path="$PREFIX/etc" \
--with-config-file-scan-dir="$PREFIX/etc/conf.d" \
--prefix=$PREFIX"
  
  if [ ! -d "$PREFIX/etc/conf.d" ]; then
    mkdir -p "$PREFIX/etc/conf.d"
  fi

  # Set the lib dir to `lib64` on **x86_64** systems.
  if [ "$(uname -p)" = "x86_64" ]; then
    argv="$argv --with-libdir=lib64"
  fi

  # enable PEAR if PHP version < 5.3
  [[ $VERSION_MAJOR < 5 || $VERSION_MINOR < 3 ]] && enable_pear

  # perform build / configure
  ./buildconf --force > /dev/null

  phpenv-hooks install pre-configure

  ./configure $argv > /dev/null

  phpenv-hooks install post-configure

}

# Here the magic begins
# ---------------------

# always ensure we have cloned the php-src repo
init

# Display the Usage message if no arguments are given.
if [[ -z $1 || "$1" = "--help" || "$1" = "-h" ]]; then
  display_usage
  exit 1
fi

# display list of available releases if --releases was passed in
if [[ "$1" = "--releases" ]]; then
  list_releases
  exit 0
fi



echo "$DEFAULT_INI gets used as php.ini"
# Generate the Path for the build log.
LOG_PATH="/tmp/phpenv-install-$RELEASE.$(date "+%Y%m%d%H%M%S").log"
# Redirect everything logged to STDOUT to the Log file.
exec 5>$1
exec >$LOG_PATH
# Redirect everything logged to STDERR to the .err Log file.
exec 4<>$LOG_PATH.err

echo
echo "Building $RELEASE"
echo

# Handle script termination with the `cleanup_abort`.
trap cleanup_abort SIGINT SIGTERM

# Handle Script Errors with `build_error`.
trap build_error ERR EXIT

# start build / install process
install_release

# Unbind the error handler.
trap - ERR
trap - EXIT

# Display a notice if build warnings got logged.
if [[ -n $LOG_PATH ]]; then
  log "Info" "The Log File is not empty, but the build did not fail.
       Maybe just warnings got logged?
       You can review the log at $LOG_PATH"
fi

log "Success" "Built $RELEASE successfully."
[[ -z $PAGER ]] && PAGER=less
test `which pbcopy` && (echo $PAGER $LOG_PATH | `which pbcopy`) && echo "The command to view the logfile with \$PAGER has been copied to your clipboard."

trap - SIGINT
trap - SIGTERM

# Reset the default streams and close file descriptors
exec 2>&3 4>&- 3>&- 1>&5 5>&-
